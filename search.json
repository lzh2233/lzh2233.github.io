[{"title":"Arknight","url":"/2022/03/31/Arknight/","content":"这是我的个人博客\n\n\n\n豆⛟浆⛟\n\n","tags":["明日方舟"]},{"title":"二叉堆与并查集","url":"/2023/01/12/%E4%BA%8C%E5%8F%89%E5%A0%86%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"如果理解递归有困难的，可以先看之前的章节\n\n\n二叉堆\n又称优先队列，此文中我们简称堆(heap)\n\n堆是可以返回该集合的最值的数据结构，但是排序算法也是可以查询最值，那么堆有什么独特的优势吗？我们可以先看看堆的成员方法的时间复杂度：push&amp;pop时间复杂度皆为O(㏒₂n)，查询最值O(1)。可以看出，堆可以在线的回答当前的最值，即动态维护最值；而排序算法多用于事先确定的数集。\n在平时的算法比赛或者练习中我们都是使用STL中提供的priority_queue泛型，但是理解其代码实现也是大有裨益之事。\npriority_queue的C++实现\n该实现支持push，pop，top操作\n\n#include &lt;iostream&gt;#define lc (u &lt;&lt; 1)#define rc (u &lt;&lt; 1 | 1)#define pa (u &gt;&gt; 1)using namespace std;const int N = 1e5 + 10;int h[N], cnt;void down(int u)&#123;    int t = u;    if ((lc) &lt;= cnt &amp;&amp; h[lc] &lt; h[t]) t = lc;    if ((rc) &lt;= cnt &amp;&amp; h[rc] &lt; h[t]) t = rc;        if (u != t)    &#123;        swap(h[t], h[u]);        down(t);    &#125;&#125;void up(int u)&#123;    if (pa &amp;&amp; h[pa] &gt; h[u])    &#123;        swap(h[pa], h[u]);        up(pa);    &#125;&#125;int top()&#123;    return h[1];&#125;void push(int x)&#123;\th[++cnt] = x;    up(cnt);&#125;void pop()&#123;    swap(h[1], h[cnt]);    cnt -- ;    down(1);&#125;\n\n堆掌握这些就足够了，以后在学习过程中不会手写堆的\n并查集\n以后LCA问题中tarjan算法会用到哦\n\n并查集是支持合并集合，询问俩个元素是否在一个集合当中的数据结构，具体内容我们课上讲。\n路径压缩优化示意图：\n\n\n例题\nA-程序自动分析\n\n在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设 𝑥1, 𝑥2, 𝑥3, ⋯ 代表程序中出现的变量，给定 𝑛 个形如 𝑥𝑖 &#x3D; 𝑥𝑗 或 𝑥𝑖 ≠ 𝑥𝑗 的变量相等&#x2F;不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为： 𝑥1 &#x3D; 𝑥2, 𝑥2 &#x3D; 𝑥3, 𝑥3 &#x3D; 𝑥4, 𝑥1 ≠ 𝑥4 ，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。\n输入描述:第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。对于每个问题，包含若干行：第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj。\n\n输出描述:包括t行。第k行输出一个字符串“YES”或者“NO”（不包含引号，字母全部大写），“YES”表示输入中的第k个问题判定为可以被满足，“NO”表示不可被满足。   \n\n输入221 2 11 2 021 2 12 1 1\n\n输出NOYES\n\n说明在第一个问题中，约束条件为：x1=x2,x1≠x2。这两个约束条件互相矛盾，因此不可被同时满足。在第二个问题中，约束条件为：x1=x2,x2=x1。这两个约束条件是等价的，可以被同时满足。\n\n备注:1≤n≤1000001≤i,j≤1000000000\n\n参考代码#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;using PII = pair&lt;int,int&gt;;const int N = 2e5 + 10;int T, n, cnt;int fa[N];vector&lt;PII&gt; v[2];unordered_map&lt;int,int&gt; lsh;void init()&#123;    for(int i = 1; i &lt; N; i ++ )&#123;        fa[i] = i;    &#125;    v[0].clear(), v[1].clear();    cnt = 0;    lsh.clear();&#125;int find(int x)&#123;    if(x == fa[x]) return x;    return fa[x] = find(fa[x]);&#125;void push(int a, int b)&#123;    int pa = find(a), pb = find(b);    if(pa != pb)&#123;        fa[pa] = pb;    &#125;&#125;signed main()&#123;    cin &gt;&gt; T;    string ans;    while(T -- )&#123;        cin &gt;&gt; n;        init();        ans = &quot;YES\\n&quot;;        for(int i = 1; i &lt;= n; i ++ )&#123;            int a, b, c;            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;            if(c) v[1].push_back(&#123;a, b&#125;);            else v[0].push_back(&#123;a, b&#125;);            if(lsh[a] == 0) lsh[a] = ++ cnt;            if(lsh[b] == 0) lsh[b] = ++ cnt;        &#125;        for(auto k : v[1])&#123;            push(lsh[k.first], lsh[k.second]);        &#125;        for(auto k : v[0])&#123;            if(find(lsh[k.first]) == find(lsh[k.second]))&#123;                ans = &quot;NO\\n&quot;;                break;            &#125;        &#125;        cout &lt;&lt; ans;    &#125;&#125;\n\n实战Supermarket\nA-Supermarket\n\n参考代码#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define T first#define V secondusing namespace std;using PII = pair&lt;int,int&gt;;const int N = 1e4 + 10;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap;PII q[N];signed main()&#123;    int n;    while(cin &gt;&gt; n)&#123;            for(int i = 0; i &lt; n; i ++ )cin &gt;&gt; q[i].V &gt;&gt; q[i].T;    sort(q, q+n);    heap.push(q[0].V);    for(int i = 1; i &lt; n; i ++ )&#123;        if(q[i].T == heap.size() &amp;&amp; q[i].V &gt; heap.top()) heap.pop(), heap.push(q[i].V);        else if(q[i].T &gt; heap.size()) heap.push(q[i].V);    &#125;    long long ans = 0;    while(heap.size())ans += heap.top(), heap.pop();    cout &lt;&lt; ans &lt;&lt; endl;        &#125;&#125;\n\n","categories":["课件","数据结构"],"tags":["C ++","算法基础"]},{"title":"哈希表","url":"/2023/01/13/%E5%93%88%E5%B8%8C%E8%A1%A8/","content":"本章无需前置知识\n\n\n哈希表哈希表之前有讲过，就不再举例子了，课上将直接讲解\n俩种解决哈希冲突的方法\n\n拉链法\n开放寻址法\n\n\n例题：\n维护一个集合，支持如下几种操作：\n\nI x，插入一个数 x；\nQ x，询问数 x 是否在集合中出现过；\n\n现在要进行 N 次操作，对于每个询问操作输出对应的结果。\n输入格式第一行包含整数 N，表示操作数量。\n接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。\n输出格式对于每个询问指令 Q x，输出一个询问结果，如果 x 在集合中出现过，则输出 Yes，否则输出 No。\n每个结果占一行。\n数据范围1≤N≤10^5−10^9≤x≤10^9\n输入样例：5I 1I 2I 3Q 2Q 5\n\n输出样例：YesNo\n\n拉链法#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int h[N], e[N], ne[N], idx;int ha(int x)&#123;    return (x % N + N) % N;&#125;void add(int a, int b)&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void insert(int x)&#123;    int t = ha(x);        add(t, x);&#125;bool query(int x)&#123;    int t = ha(x);        for (int i = h[t]; ~i; i = ne[i])    &#123;        int j = e[i];        if (j == x) return true;    &#125;        return false;&#125;int main()&#123;    int T;    cin &gt;&gt; T;        memset(h, -1, sizeof h);        while (T -- )    &#123;        char op; int x;        cin &gt;&gt; op &gt;&gt; x;                if (op == &#x27;I&#x27;) insert(x);        else         &#123;            if (query(x)) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;    &#125;        return 0;&#125;\n\n开放寻址法#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 2e5 + 10;int h[N], null = 0x3f3f3f3f;int ha(int x)&#123;    return (x % N + N) % N;&#125;void insert(int x)&#123;    int t = ha(x);        while (h[t] != null &amp;&amp; h[t] != x)    &#123;        t = (t + 1) % N;    &#125;        h[t] = x;&#125;bool query(int x)&#123;    int t = ha(x);        while (h[t] != x &amp;&amp; h[t] != null)    &#123;        t = (t + 1) % N;    &#125;        return h[t] == x;&#125;int main()&#123;    int T;    cin &gt;&gt; T;        memset(h, 0x3f, sizeof h);        while (T -- )    &#123;        char op;        int x;        cin &gt;&gt; op &gt;&gt; x;                if (op == &#x27;I&#x27;) insert(x);        else        &#123;            if (query(x)) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;     &#125;    return 0;&#125;\n\n\n字符串哈希全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），实现不同的字符串映射到不同的数字。对形如 X1X2X3⋯Xn−1Xn 的字符串,采用字符的ascii 码乘上 P 的次方来计算哈希值。\n映射公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ注意点：\n\n任意字符不可以映射成0，否则会出现不同的字符串都映射成0的情况，比如A,AA,AAA皆为0冲突问题：\n通过巧妙设置P (131 或 13331) , Q (2^64)的值，一般可以理解为不产生冲突。\n\n\n例题：\n给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1]和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。\n字符串中只包含大小写英文字母和数字。\n输入格式第一行包含整数 n 和 m，表示字符串长度和询问次数。\n第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。\n接下来 m 行，每行包含四个整数 l1,r1,l2,r2，表示一次询问所涉及的两个区间。\n注意，字符串的位置从 1 开始编号。\n输出格式对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。\n每个结果占一行。\n数据范围1≤n,m≤10^5\n输入样例：8 3aabbaabb1 3 5 71 3 6 81 2 1 2\n\n输出样例：YesNoYes\n\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010, P = 131;int n, m;char str[N];ULL h[N], p[N];ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    scanf(&quot;%s&quot;, str + 1);    p[0] = 1;    for (int i = 1; i &lt;= n; i ++ )    &#123;        h[i] = h[i - 1] * P + str[i];        p[i] = p[i - 1] * P;    &#125;    while (m -- )    &#123;        int l1, r1, l2, r2;        scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);        if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);    &#125;    return 0;&#125;\n\n\n我们数据结构学习到这里就告一段落了\n","categories":["课件","数据结构"],"tags":["C ++","算法基础"]},{"title":"简单的递归学习","url":"/2023/01/02/%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92%E5%AD%A6%E4%B9%A0/","content":"本章无需前置知识，但最好了解如何存储树结构（可参考链表与邻接表）🙂\n\n\n递归（入门）我们先来看基础的递归写法结构：\nvoid dfs()&#123;    if(condition()) return;\t//结束条件    dfs();&#125;\n\n再来看看经典的求最大公因数gcd递归写法：\nint gcd(int a, int b)&#123;   return b ? gcd(b, a%b) : a; &#125;\n\n可见递归从形式上来看就是自己调用自己，而自己调用自己也存在着无法停下的风险，所以需要条件来结束递归。\n而就形式上的了解是不可能掌握递归的。所以，接下来我们来讲递归的常用应用场景：树状结构的问题。\n递归遍历树 \n先来个问题，面对一棵树，怎么遍历？\n按照线性（比如数组）的遍历方法肯定是不行的（邻接表这么遍历也太掉逼格了）这里我们就可以使用递归，之后在图论中我们称此为dfs（深度优先搜索）。我们先来一个demo\ndemo自己编的，不要在意\n\n这里有棵树，每个节点上都有数值，定义每个节点的价值为节点数值乘上其深度（距离根节点的距离+1，根节点深度为1），树的价值是所有节点价值的和，求出给定树的价值。\n\ninput\n6\t\t\t//树有的节点数1 2 3 4 5 6 //第i个数是节点i的数值1 2 \t\t//节点1 指向 节点22 3 1 4 2 5 5 6 \n\noutput\n61\n\ncode\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int n;int h[N], ne[N], e[N], idx;int v[N];void init()&#123;    memset(h, -1, sizeof h);    idx =-1;&#125;void add(int x, int y)&#123;    e[++ idx] = y, ne[idx] = h[x], h[x] = idx;&#125;int ans;void dfs(int u, int deep)&#123;    ans += v[u]*deep;    for(int i = h[u]; ~i; i = ne[i])&#123;        dfs(e[i], deep + 1);    &#125;&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    init();    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i ++ )&#123;        cin &gt;&gt; v[i];    &#125;    for(int i = 1; i &lt; n; i ++ )&#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;        add(x, y);    &#125;    dfs(1, 1);    cout &lt;&lt; ans &lt;&lt;endl;&#125;\n\n重点看一下这段代码：\nvoid dfs(int u, int deep)&#123;    //u为当前遍历的节点，deep为当前深度    ans += v[u]*deep;    for(int i = h[u]; ~i; i = ne[i])&#123;        dfs(e[i], deep + 1);\t//遍历u所邻接的节点e[i]，树的深度加一    &#125;&#125;\n","categories":["课件","搜索"],"tags":["C ++","算法基础"]},{"title":"栈和队列","url":"/2023/01/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","content":"本章无需前置知识\n\n\n栈和队列\n很简单的数据结构\n\n栈\n栈是一种先进后出，是一种很简单的数据结构，此处会介绍简单的栈变形。\n\nlzh先列个题表：\n\nEditor——模拟光标\nLargest Rectangle in a Historgram\n\n以上都是可以用栈完成或栈所衍生出来的问题\nEditor\n维护一个整数编辑器，有以下五种操作，操作不超过1e6。\nI x：在光标处插入整数x，插入后将光标移至x后；\nD：删掉光标前的数\nL：光标左移\nR：光标右移\nQ k： 询问在位置k之前的最大前缀和，k不得超过当前光标\n\n这题是可能刚拿到时会有点懵，但是如果想想栈的方法，就会出现思路。\n对顶栈lzh发现，这题若只有插入删除功能，可能就用普通的链表就行了。但是这题有要求光标的左进 &#x2F; 右进模拟，所以用一个对顶栈模拟更为容易形象——\n首先，在一切开始前，lzh 建立了两个栈：k1和k2，再建立个前缀和数组sum与维护最大前缀和的数组f\nI   操作\n\n把x压入看k1栈\n更新sum[top1] = sum[top1 - 1] + x\n对f[top1] = max(f[top1 - 1], f)\n\nD  操作： 把k1的栈顶出栈\nL  操作： 弹出k1的栈顶，压入k2\nR  操作\n\n弹出k2的栈顶，压入k1\n更新sum[top1] = sum[top1 - 1] + 1\n对f[top1] = max(f[top1 - 1], f)\n\nQ  操作：访问f[k]\ninput\n8I 2I -1I 1Q 3LDRQ 2\n\noutput\n23\n\nCode\n#include &lt;iostream&gt;#define please return#define ac 0;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int k1[N], k2[N];int f[N];int sum[N];int top1, top2;void init()&#123;    top1 = top2 = 0;    f[0] = -INF;&#125;signed main()&#123;    ios::sync_with_stdio(false), cin.tie(nullptr);     init();        char op;    int m;        cin &gt;&gt; m;    while(m -- )    &#123;        cin &gt;&gt; op;        if(op == &#x27;I&#x27;)        &#123;            int x;            cin &gt;&gt; x;            k1[ ++ top1] = x;            sum[top1] = sum[top1 - 1] + x;            f[top1] = max(f[top1 - 1], sum[top1]);         &#125;        else if(op == &#x27;D&#x27;)        &#123;            if(!top1) continue;            top1 -- ;        &#125;        else if(op == &#x27;L&#x27;)        &#123;            if(!top1) continue;            k2[++ top2] = k1[top1];            top1 -- ;        &#125;        else if(op == &#x27;R&#x27;)        &#123;            if(!top2) continue;            k1[++ top1] = k2[top2];            top2 -- ;            sum[top1] = sum[top1 - 1] + k1[top1];            f[top1] = max(f[top1 - 1], sum[top1]);        &#125;        else if(op == &#x27;Q&#x27;)        &#123;            int k;            cin &gt;&gt; k;            cout &lt;&lt; f[k] &lt;&lt; endl;        &#125;        // else if(op == &#x27;O&#x27;)\t\t//可以看看实际效果        // &#123;        //     for(int i = 1; i &lt;= top1; i ++ )        //     &#123;        //         cout &lt;&lt; k1[i]&lt;&lt; &#x27; &#x27;;        //     &#125;        //     cout &lt;&lt; &#x27;^&#x27; &lt;&lt; &#x27; &#x27;        //     for(int i = top2; i &gt; 0; i -- )        //     &#123;        //         cout &lt;&lt; k2[i] &lt;&lt; &#x27; &#x27;;        //     &#125;        //     cout &lt;&lt; endl;        // &#125;    &#125;        please ac&#125;·\n\nLargest Rectangle in a Historgram如图所示，在一条水平线上方有若干个矩形（宽度默认为1），求包含于这些矩形的并集内部的最大矩形的面积（在下图中，答案为阴影部分的面积），矩形个数 ≤ 1e5。\n\n输入描述\n\n输入包含几个测试用例。每个测试用例描述一个直方图，并以整数n开始，表示由矩形组成的数量。可以假设1≤n≤100000。然后取n个整数h1…hn，其中0≤hi≤1000000000。这些数字表示直方图中从左到右的矩形的高度。每个矩形的宽度为1。最后一个测试用例的输入后面跟着一个0。\n\n输出描述\n\n对于单行上的每个测试用例输出，指定直方图中最大矩形的面积。记住，这个矩形必须在公共基线上对齐。\n\n单调栈这题需要单调栈来维护的，什么是单调栈呢？如下：\ncin &gt;&gt; a;while(k.top() &gt; a) k.pop(); // k是单调递增栈k.push(a);\n\n单调栈维护矩形的高\ninput\n7 2 1 4 5 1 3 34 1000 1000 1000 10000\n\noutput\n84000\n\ncode\n#include &lt;iostream&gt;#include &lt;stack&gt;#define please return#define ac 0;using namespace std;using ll = long long;const int N = 1e5 + 10;struct Node&#123;    int h, w;&#125;;stack&lt;Node&gt; k;signed main()&#123;    ios::sync_with_stdio(false), cin.tie(nullptr);    int n;    while(cin &gt;&gt; n, n)    &#123;        ll ans = 0;        stack&lt;Node&gt; k;        k.push(&#123;0,0&#125;);\t\t// 方便初动        for(int i = 0; i &lt;= n; i ++ )        &#123;            int h, w = 1;            if(i != n) cin &gt;&gt; h;            else h = 0;\t\t\t\t// 在最后的最后在栈中放入0，以便清栈            if(h &gt;= k.top().h)                k.push(&#123;h, w&#125;);            else            &#123;                w = 0;                while(k.top().h &gt; h)                &#123;                    w += k.top().w;                    ans = max(ans, (ll)w * k.top().h);                    k.pop();                &#125;                k.push(&#123;h, w + 1&#125;);            &#125;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    please ac&#125;\n\n队列\n队列是一种先进先出的数据结构，像排队一样\n\n队列与栈一样，是一种很简单的数据结构，我们可以手写而不去调用C++ STL中的,原因有二——一是手写的灵活，二是快。\n跟栈一样，队列也有其相应的变形。这里先列出本文的题表：\n\nTeam Queue\n简单的滑动窗口类问题\n\n以上是可以使用队列解决的问题\nTeam Queue\n这是一道简单的模拟题哦，就拿这道开刀吧。\n\n\n原题情境：中午排队吃饭，队列中有n个小组，每个小组有若干人。当一个人来到队伍时，如果有自己的组员自然是要插入该组的队尾，否则就排在队伍的最后边。给定不超过2e5个入队指令和出队指令，最后输出出队顺序。\n\n在任何时刻，同一个小组的人都会站在一起，所以队伍中小组的状态就只有两种——有无这个小组，所以我们可以用队列Q来维护小组在队列中的位置，用队列g[N]来存储小组成员的顺序，然后是单纯的模拟。\n输入描述：\n有多次样例输入\n第1行输入组数T（1≤T≤1000）如果T&#x3D;0，结束程序\n第2~T+1行输入组员个数n和n个小组成员编号num （n&lt;1000, num&lt; 1000000）\n第n+2行开始输入指令：\n\nENQUEUE num 将num入队\nDEQUEUE 将队头出队\nSTOP 结束样例操作\n\n\n输出描述\n对于第k组样例，第一行应该这么说：Scenario #k\n接下来输出该样例的出队顺序\n\nInput\n23 101 102 1033 201 202 203ENQUEUE 101ENQUEUE 201ENQUEUE 102ENQUEUE 202ENQUEUE 103ENQUEUE 203DEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP25 259001 259002 259003 259004 2590056 260001 260002 260003 260004 260005 260006ENQUEUE 259001ENQUEUE 260001ENQUEUE 259002ENQUEUE 259003ENQUEUE 259004ENQUEUE 259005DEQUEUEDEQUEUEENQUEUE 260002ENQUEUE 260003DEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP0\n\nOutput\nScenario #1101102103201202203Scenario #2259001259002259003259004259005260001\n\nCode\n#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define please return#define ac 0;#define loop while(1)using namespace std;const int N = 1e3 + 10, M = 1e6 + 10;int Q[N], hh, tt;queue&lt;int&gt; g[N];int st[M];      //记录成员所属组int k;void init()&#123;    memset(Q, 0, sizeof Q);    hh = 0, tt = -1;    memset(st, 0, sizeof st);    for(int i = 0; i &lt; N; i ++ )        while(g[i].size())g[i].pop();&#125;signed main()&#123;    ios::sync_with_stdio(false), cin.tie(nullptr);    int n;    while(cin &gt;&gt; n, n)    &#123;        init();        cout &lt;&lt; &quot;Scenario #&quot; &lt;&lt; ++ k &lt;&lt; &#x27;\\n&#x27;;        for(int i = 1; i &lt;= n; i ++ )        &#123;            int T;            cin &gt;&gt; T;            while(T -- )            &#123;                int num;                cin &gt;&gt; num;                st[num] = i;            &#125;        &#125;                string op;        while(cin &gt;&gt; op, op != &quot;STOP&quot;)        &#123;            if(op == &quot;ENQUEUE&quot;)            &#123;                int x;                cin &gt;&gt; x;                int t = st[x];                if(g[t].empty())                &#123;                    Q[++ tt] = t;                &#125;                g[t].push(x);            &#125;            else            &#123;                if(hh &lt;= tt)                &#123;                    int t = Q[hh];                    cout &lt;&lt; g[t].front() &lt;&lt; &#x27;\\n&#x27;;                    g[t].pop();                    if(g[t].empty())hh ++ ;                &#125;            &#125;        &#125;        cout &lt;&lt; endl;    &#125;    please ac&#125;\n\n滑动窗口类\n这是一类问题，这里只讲长度的区间最大值问题\n\n我们这先来个引例：\n\n给出一段数列V，求出每段长度为k的区间里的最大值\n\n这里要是没有时间限制，大家大可暴力解决此题，然额呢，既然来看此文的肯定不能接受这种O(n^2)复杂度的算法，所以此类固定长度的子序列中的最大值问题是可以使用队列解决，不过普通的队列是解决不了的，这里就需要单调队列了。\n单调队列跟单调栈一样，同样是对队列加了约束条件——\ncin &gt;&gt; a;while(q.back() &gt; a)q.pop_back(); \t//单调递增的队列q.push_back(a);\n\n从上式的代码来看，好像和单调栈没啥区别，但可不要忘记队列是可以从队头出队列的，可以保证队列像滑动的窗口一样，本题是要求我们固定长度的区间最大值，即长度固定，那么我们可以用单调队列维护区间长度。还有一点我们还没有讲明白，那就是为什么单调队列可以O(n)解决此类问题。\n我们可以任取两点i 、j且i &lt; j， 如果V[i] &lt; V[j]，那么i就可以出队列了，因为i&lt;j，会比j先出队列，而V[j]又比V[i]大，对结果贡献更大。所以当j出现后，i就是完全无用的位置了。\n以上得出的结论，我们已经可以完成此道引例：\n#include &lt;iostream&gt;#define please return#define ac 0;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int q[N], hh, tt;int a[N];int mx[N];int n, len;void init()&#123;    hh = 1, tt = 0;&#125;void findMax()&#123;    init();    for(int i = 1; i &lt;= n; i ++ )    &#123;        while(a[q[tt]] &lt; a[i])tt -- ;        q[++ tt] = i;        while(q[tt] - q[hh] + 1 &gt; len)hh ++ ;        if(i &gt;= len) mx[i - len + 1] = a[q[hh]];    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false), cin.tie(nullptr);    cin &gt;&gt; n &gt;&gt; len;    a[0] = INF;    for(int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];    a[n + 1] = INF;    findMax();    for(int i = 1; i &lt;= n - len + 1; i ++ ) cout &lt;&lt; mx[i] &lt;&lt; &#x27; &#x27;;    please ac&#125;\n\n可以看出，每个元素只进出一次队列，故其时间复杂度为O(n)。\n例题\n输入一个长度为n的整数序列，从中找出一段不超过m的连续子序列，使得整个序列的和最大。 例如 1,-3,5,1,-2,3 当m&#x3D;4时，S&#x3D;5+1-2+3&#x3D;7 当m&#x3D;2或m&#x3D;3时，S&#x3D;5+1&#x3D;6\n\n输入描述\n第一行两个数n,m（n,m≤300000） 第二行有n个数，要求在n个数找到最大子序和\n\n输出描述\n一个数，数出他们的最大子序和\n\nInput\n6 41 -3 5 1 -2 3\n\nOutput\n7\n\nCode\n#include &lt;iostream&gt;#include &lt;deque&gt;#define please return#define ac 0;using namespace std;const int N = 1e7 + 10;deque&lt;int&gt; q;\t//就当作是单调队列吧int s[N];signed main()&#123;    int n, l;    cin &gt;&gt; n &gt;&gt; l;    for(int i = 1; i &lt;= n; i ++ )&#123;        int a;        cin &gt;&gt; a;        s[i] = s[i - 1] + a;    &#125;    int ans = -0x3f3f3f3f;    q.push_back(0);    for(int i = 1; i &lt;= n; i ++ )&#123;        while(q.size() &amp;&amp; s[q.back()] &gt;= s[i])q.pop_back();        q.push_back(i);        while(q.size() &amp;&amp; i - q.front() &gt; l) q.pop_front();        ans = max(ans, s[i] - s[q.front()]);            &#125;    cout &lt;&lt; ans &lt;&lt; endl;        please ac&#125;\n","categories":["课件","数据结构"],"tags":["C ++","算法基础"]},{"title":"组合数学笔记","url":"/2022/04/13/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"组合数应用甚为广泛，之前做过笔记，这次算补档。\n\n\n组合数学的先行版\n我记得我记过组合数学的笔记呀😡\n\n求组合数求组合数有很多种方式，我们需要通过数据范围来选出适合的方式，以如下例题为例👇\n\n给定 n 组询问，每组询问给定两个整数 a，b请你输出 C a b mod(10^9+7) 的值。\n\n第一种（递推式）公式： C(a, b) &#x3D; C (a - 1, b) + C(a - 1, b - 1)\n此类方法的数据范围： 10 ^ 3 &lt; b ≤ a &lt; 10 ^ 4\n代码实现：#include &lt;iostream&gt;using namespace std;const int N = 2010;const int MOD = 1e9 + 7;int c[N][N];void init()                         //时间复杂度O(n ^ 2), 空间复杂度O(n ^ 2)&#123;    for(int i = 0; i &lt; N; i ++ )    &#123;        for(int j = 0; j &lt;= i; j ++ )               &#123;            if(!j) c[i][j] = 1;                                                 else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;       //递推            &#125;    &#125;&#125;int main()&#123;    init();    int T;    cin &gt;&gt; T;    while(T -- )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; c[a][b] &lt;&lt; endl;    &#125;    return 0;&#125;\n\n第二种（乘法逆元和前缀乘预处理）公式： C(a, b) &#x3D; a! &#x2F; [(a - b)! × b!]   &#x3D;&#x3D;&gt;  C(a, b) &#x3D; a! × inv((a- b)! × b!) \n此类方法的数据范围： 1 ≤ b ≤a ≤ 10^5\n代码实现：#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;const int MOD = 1e9 + 7;int fact[N], inv[N];int qkm(int a, int k, int p)&#123;    int res = 1;    while(k)    &#123;        if(k &amp; 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;void init()&#123;    fact[0] = inv[0] = 1;           //c(0,0)的初始化    for(int i = 1; i &lt; N; i ++ )    &#123;        fact[i] = (LL)fact[i - 1] * i % MOD;        // 前缀乘or阶乘递推        inv[i] = (LL) inv[i - 1] * qkm(i, MOD - 2, MOD) % MOD;    &#125;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    init();    while(T -- )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; ((LL)fact[a] * inv[b] % MOD * inv[a- b] % MOD) % MOD &lt;&lt; endl;    &#125;    return 0;&#125;\n\n第三种（Lucas定理）公式： C(a, b) % P &#x3D; C(a%P, b%P) × C(a&#x2F;P, b&#x2F;P)\n此类方法的数据范围： 1≤b≤a≤10^18,  1≤p≤10^5\n代码实现：#include &lt;iostream&gt;using namespace std;typedef long long LL;int qkm(int a, int k, int p)&#123;    int res = 1;    while(k)    &#123;        if(k &amp; 1) res = res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;int C(int a, int b, int p)&#123;    if(b &gt; a) return 0;         //组合数不存在    int res = 1;    for(int i = 1, j = a; i &lt;= b; i ++ , j -- )    &#123;        res = (LL)res * j % p;              //阶乘的递推        res = (LL)res * qkm(i, p - 2, p) % p;       \t//乘法逆元    &#125;    return res;&#125;int lucas(LL a, LL b, int p)        //lucas定理中p为质数,且不宜太大&#123;    if(a &lt; p &amp;&amp;  b &lt; p) return C(a, b, p);    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T -- )    &#123;        LL a, b;        int p;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;        cout &lt;&lt; lucas(a, b, p) &lt;&lt; endl;    &#125;    return 0;&#125;\n\n第四种(对阶乘分解质因数 + 高精度)\n及其硬核，不是吗\n\n当以上范围超出以上三种或没有进行取余\n代码实现：#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 5010;int primes[N], cnt;int sum[N];bool st[N];void get_primes(int n)&#123;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        &#123;            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        &#125;    &#125;&#125;int get(int n, int p)&#123;    int res = 0;    while (n)    &#123;        res += n / p;        n /= p;    &#125;    return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)&#123;    vector&lt;int&gt; c;    int t = 0;    for (int i = 0; i &lt; a.size(); i ++ )    &#123;        t += a[i] * b;        c.push_back(t % 10);        t /= 10;    &#125;    while (t)    &#123;        c.push_back(t % 10);        t /= 10;    &#125;    return c;&#125;int main()&#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    get_primes(a);    for (int i = 0; i &lt; cnt; i ++ )    &#123;        int p = primes[i];        sum[i] = get(a, p) - get(a - b, p) - get(b, p);    &#125;    vector&lt;int&gt; res;    res.push_back(1);    for (int i = 0; i &lt; cnt; i ++ )        for (int j = 0; j &lt; sum[i]; j ++ )            res = mul(res, primes[i]);    for (int i = res.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, res[i]);    puts(&quot;&quot;);    return 0;&#125;\n\n下次拿python覆写一遍。\n番外の数——卡特兰数\n作为卡特兰数，这个世界上很多方案数都是卡特兰数，拥有和斐波那契数一样的地位\n\n表达形式：\n\nf(n)&#x3D;f(0)×f(n−1)+f(1)×f(n−2)+…+f(n−1)×f(0)\nf(n)&#x3D;C(2n, n) - C(2n , n - 1)\nf(n)&#x3D;C(2n, n) &#x2F; (n + 1)\n\n卡特兰数的初始化： f(0) &#x3D; 1\n例题展示给定 n 个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 0 的个数都不少于 1 的个数的序列有多少个。\n输出的答案对 10^9+7 取模。\n输入格式共一行，包含整数 n。\n输出格式共一行，包含一个整数，表示答案。\n数据范围1≤n≤10^5\n输入样例：3\n\n输出样例：5\n\n代码实现：#include &lt;iostream&gt;using namespace std;typedef long long LL;const int MOD = 1e9 + 7;int qkm(int a, int k, int p)&#123;    int res = 1;    while(k)    &#123;        if(k &amp; 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    int a = n * 2;    int b = n;    int f = 1;    for(int i = a; i &gt; b; i -- ) f = (LL)f * i % MOD;    for(int i = 1; i &lt;= n; i ++ ) f = (LL)f * qkm(i, MOD - 2, MOD) % MOD;    cout &lt;&lt; f &lt;&lt; endl;    return 0;&#125;\n\n暂完\n","categories":["算法","笔记"],"tags":["C ++"]},{"title":"链表与邻接表","url":"/2023/01/01/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/","content":"本章无需前置知识\n\n\n链表与邻接表\n此处我介绍链式前向星的写法\n\n链式前向星的写法是使用数组去模拟链表，因不用反复申请空间而效率很高。而其核心思想就是先申请个内存池，动态开点。\n链表单向链表模板#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;//此处内存池大小为N，-1是链表结束标记，起初链表为空，head=-1int head = -1, ne[N], node[N], idx = -1;\tvoid add(int x)&#123;    node[++ idx] = x, ne[idx] = head, head = idx;&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    int n;    cin &gt;&gt; n;    int m = n;    while(m -- )&#123;        int x;        cin &gt;&gt; x;        add(x);    &#125;    for(int i = head; ~i; i = ne[i])&#123;        cout &lt;&lt; node[i] &lt;&lt; endl;    &#125;&#125;\n\n双向链表模板#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int m;int l[N], r[N], e[N], idx = 2;void init()&#123;    r[0] = 1, l[1] = 0;&#125;void insert_l(int x)&#123;    e[idx] = x;    l[idx] = 0;    r[idx] = r[0];    l[r[0]] = idx, r[0] = idx ++ ;&#125;void insert_r(int x)&#123;    e[idx] = x;    l[idx] = l[1];    r[idx] = 1;    r[l[1]] = idx, l[1] = idx ++ ;&#125;void remove(int i)&#123;    l[r[i]] = l[i], r[l[i]] = r[i];&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    cin &gt;&gt; m;    init();    while(m -- )&#123;        char opt;        int x;        cin &gt;&gt; opt &gt;&gt; x;        if(opt == &#x27;l&#x27;)&#123;            insert_l(x);        &#125;else if(opt == &#x27;r&#x27;)&#123;            insert_r(x);        &#125;else&#123;            remove(x);        &#125;    &#125;    for(int i = r[0]; i != 1; i = r[i])&#123;        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for(int i = l[1]; i != 0; i = l[i])&#123;        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    &#125;    &#125;\n\n邻接表\n可以存储树状数据的一种数据结构\n\n邻接表，做个简单的假设：有一数组记录了若干节点，数组节点上存储一链表，该链表记录了该节点所直接能通往的所有节点。这就是所谓的邻接，而这类似二维数组的数据结构，我们可以称之为邻接表。\n邻接表模板(数组实现)#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;const int M = 1e6 + 10;int head[N], ne[M], e[M], idx;void add(int x, int y)&#123;    // x -&gt; y    e[++ idx] = y, ne[idx] = head[x], head[x] = idx;&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    int m, n;    cin &gt;&gt; m &gt;&gt; n;    while(m -- )&#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;        add(x, y);        //add(y, x) 双向边    &#125;    //遍历各个点的邻接点    for(int i = 1; i &lt;= n; i ++ )&#123;        cout &lt;&lt; i &lt;&lt; &quot;: &quot;;        for(int j = head[i]; j; j = ne[j])&#123;            cout &lt;&lt; e[j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;\n\n使用Vector实现#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5 + 10;vector&lt;int&gt; tb[N];signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    int m, n;    cin &gt;&gt; m &gt;&gt; n;    while(m -- )&#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;        tb[x].push_back(y);    &#125;    for(int i = 1; i &lt;= n; i ++ )&#123;        cout &lt;&lt; i &lt;&lt; &quot;: &quot;;        for(auto j : tb[i])&#123;            cout &lt;&lt; j &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;\n\n邻接表存储树、图结构何为树：\n\n\n何为图：\n\n不严谨的来说，有环树为图，无环图为树。图可以描述多对多的关系，树可描述一对多的关系 （父子关系）\n树的节点与边的数量关系为 ：边数 &#x3D; 节点数 - 1\n图的节点与边的数量关系：设节点数为N，边数为M —— M ≤ (N-1)×N&#x2F;2\n邻接表存储：\n\n以至于对其的遍历方法，等以后再说吧🎃\n例题题目描述给定一个长度为 n 的序列 A，A 中的数各不相同。对于 A 中的每一个数Ai，求：min(1≤j&lt;i)⁡∣Ai−Aj∣以及令上式取到最小值的 j（记为 Pi）。若最小值点不唯一，则选择使 Aj较小的那个。\n输入描述:第一行一个整数n，第二行n个数A1~An。\n\n输出描述:n-1行，每行2个用空格隔开的整数。分别表示当i取2~n时，对应的 min(1≤j&lt;i)⁡∣Ai−Aj∣和Pi的值。\n\n参考代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;using PII = pair&lt;int,int&gt;;const int N = 1e5 + 10;struct Node&#123;    int v, id;\t\t//节点的值，在原序列的索引    int nxt, pre;\t//链表的前后指针    bool operator&lt;(const Node&amp; k)const&#123;        if(v == k.v)            return id &lt; k.id;        else            return v &lt; k.v;    &#125;&#125;q[N];int st[N];\t\t\t//记录原序列索引所对应的链表对应地址int n;PII ans[N];\t\t\t//记录答案，first记值，second记索引signed main()&#123;//     freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    ios::sync_with_stdio(false);    cin &gt;&gt; n;    q[0].v = 1e9, q[n+1].v = -1e9;    for(int i = 1; i &lt;= n; i ++ )&#123;        cin &gt;&gt; q[i].v;        q[i].id = i;    &#125;    sort(q+1, q+1+n);    for(int i = 1; i &lt;= n; i ++ )&#123;        q[i].nxt = i+1;        q[i].pre = i-1;        st[q[i].id] = i;\t\t//记录原序列索引对应链表地址关系    &#125;    for(int i = n; i &gt; 1; i -- )&#123;        int j = st[i], j1 = q[j].nxt, j2 = q[j].pre;        int r1 = abs(q[j1].v - q[j].v), r2 = abs(q[j2].v - q[j].v);        if(r1 &gt;= r2) ans[i] = &#123;r2, q[j2].id&#125;;        else ans[i] = &#123;r1, q[j1].id&#125;;        q[j1].pre = j2,q[j2].nxt = j1;\t\t//删除节点j    &#125;    for(int i = 2; i &lt;= n; i ++ )&#123;        cout &lt;&lt; ans[i].first &lt;&lt; &quot; &quot; &lt;&lt; ans[i].second &lt;&lt; endl;    &#125;&#125;\n\n\n\n课后习题\n因为过于基础，所以不太好找例题，所以本章就留点课后练习吧\n\n单链表:\n实现一个单链表，链表初始为空，支持三种操作：\n\n向链表头插入一个数；\n删除第 k 个插入的数后面的数；\n在第 k 个插入的数后插入一个数。\n\n现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。\n注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。\n输入格式第一行包含整数 M，表示操作次数。\n接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：\n\nH x，表示向链表头插入一个 x。\nD k，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。\nI k x，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。\n\n输出格式共一行，将整个链表从头到尾输出。\n数据范围1≤M≤100000所有操作保证合法。\n输入样例：10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6\n\n输出样例：6 4 6 5\n\nCode：\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int head, idx;int ne[N], e[N];int n;void init()&#123;    idx = 0;    head = -1;&#125;void add_head(int x)&#123;    e[idx] = x;    ne[idx] = head;    head = idx ++ ;&#125;void add(int k, int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx ++ ;&#125;void del(int k)&#123;    ne[k] = ne[ne[k]];&#125;int main()&#123;    cin &gt;&gt; n;        init();        while (n -- )    &#123;        char op;        int k, x;        cin &gt;&gt; op;                if (op == &#x27;H&#x27;)        &#123;            cin &gt;&gt; x;            add_head(x);        &#125;        else if (op == &#x27;D&#x27;)        &#123;            cin &gt;&gt; k;            if(!k) head = ne[head];            del(k - 1);        &#125;        else         &#123;            cin &gt;&gt; k &gt;&gt; x;            add(k - 1, x);        &#125;    &#125;        for (int i = head; ~i; i = ne[i])    &#123;        cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;    &#125;        return 0;    &#125;\n\n\n\n双链表:\n实现一个双链表，双链表初始为空，支持 5 种操作：\n\n在最左侧插入一个数；\n在最右侧插入一个数；\n将第 k 个插入的数删除；\n在第 k 个插入的数左侧插入一个数；\n在第 k 个插入的数右侧插入一个数\n\n现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。\n注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。\n输入格式第一行包含整数 M，表示操作次数。\n接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：\n\nL x，表示在链表的最左端插入数 x。\nR x，表示在链表的最右端插入数 x。\nD k，表示将第 k 个插入的数删除。\nIL k x，表示在第 k 个插入的数左侧插入一个数。\nIR k x，表示在第 k 个插入的数右侧插入一个数。\n\n输出格式共一行，将整个链表从左到右输出。\n数据范围1≤M≤100000所有操作保证合法。\n输入样例：10R 7D 1L 3IL 2 10D 3IL 2 7L 8R 9IL 4 7IR 2 2\n\n输出样例：8 7 7 3 2 9\n\nCode：\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int m;int e[N], l[N], r[N], idx;// 在节点a的右边插入一个数xvoid insert(int a, int x)&#123;    e[idx] = x;    l[idx] = a, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx ++ ;&#125;// 删除节点avoid remove(int a)&#123;    l[r[a]] = l[a];    r[l[a]] = r[a];&#125;int main()&#123;    cin &gt;&gt; m;    // 0是左端点，1是右端点    r[0] = 1, l[1] = 0;    idx = 2;    while (m -- )    &#123;        string op;        cin &gt;&gt; op;        int k, x;        if (op == &quot;L&quot;)        &#123;            cin &gt;&gt; x;            insert(0, x);        &#125;        else if (op == &quot;R&quot;)        &#123;            cin &gt;&gt; x;            insert(l[1], x);        &#125;        else if (op == &quot;D&quot;)        &#123;            cin &gt;&gt; k;            remove(k + 1);        &#125;        else if (op == &quot;IL&quot;)        &#123;            cin &gt;&gt; k &gt;&gt; x;            insert(l[k + 1], x);        &#125;        else        &#123;            cin &gt;&gt; k &gt;&gt; x;            insert(k + 1, x);        &#125;    &#125;    for (int i = r[0]; i != 1; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;    cout &lt;&lt; endl;    return 0;&#125;\n\n","categories":["课件","数据结构"],"tags":["C ++","算法基础"]}]