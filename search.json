[{"title":"Arknight","url":"/2022/03/31/Arknight/","content":"这是我的个人博客\n\n\n\n豆⛟浆⛟\n\n","tags":["明日方舟"]},{"title":"链表与邻接表","url":"/2023/01/01/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/","content":"本章无需前置知识\n\n\n链表与邻接表\n此处我介绍链式前向星的写法\n\n链式前向星的写法是使用数组去模拟链表，因不用反复申请空间而效率很高。\n列表单向链表模板#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int head = -1, ne[N], node[N], idx = -1;void add(int x)&#123;    node[++ idx] = x, ne[idx] = head, head = idx;&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    int n;    cin &gt;&gt; n;    int m = n;    while(m -- )&#123;        int x;        cin &gt;&gt; x;        add(x);    &#125;    for(int i = head; ~i; i = ne[i])&#123;        cout &lt;&lt; node[i] &lt;&lt; endl;    &#125;&#125;\n\n双向链表模板#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int m;int l[N], r[N], e[N], idx = 2;void init()&#123;    r[0] = 1, l[1] = 0;&#125;void insert_l(int x)&#123;    e[idx] = x;    l[idx] = 0;    r[idx] = r[0];    l[r[0]] = idx, r[0] = idx ++ ;&#125;void insert_r(int x)&#123;    e[idx] = x;    l[idx] = l[1];    r[idx] = 1;    r[l[1]] = idx, l[1] = idx ++ ;&#125;void remove(int i)&#123;    l[r[i]] = l[i], r[l[i]] = r[i];&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    cin &gt;&gt; m;    init();    while(m -- )&#123;        char opt;        int x;        cin &gt;&gt; opt &gt;&gt; x;        if(opt == &#x27;l&#x27;)&#123;            insert_l(x);        &#125;else if(opt == &#x27;r&#x27;)&#123;            insert_r(x);        &#125;else&#123;            remove(x);        &#125;    &#125;    for(int i = r[0]; i != 1; i = r[i])&#123;        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for(int i = l[1]; i != 0; i = l[i])&#123;        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    &#125;    &#125;\n\n邻接表\n可以存储树状数据的一种数据结构\n\n邻接表，做个简单的假设：有一数组记录了若干节点，数组节点上存储一链表，该链表记录了该节点所直接能通往的所有节点。这就是所谓的邻接，而这类似二维数组的数据结构，我们可以称之为邻接表。\n邻接表模板(数组实现)#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;const int M = 1e6 + 10;int head[N], ne[M], e[M], idx;void add(int x, int y)&#123;    // x -&gt; y    e[++ idx] = y, ne[idx] = head[x], head[x] = idx;&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    int m, n;    cin &gt;&gt; m &gt;&gt; n;    while(m -- )&#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;        add(x, y);        //add(y, x) 双向边    &#125;    //遍历各个点的邻接点    for(int i = 1; i &lt;= n; i ++ )&#123;        cout &lt;&lt; i &lt;&lt; &quot;: &quot;;        for(int j = head[i]; j; j = ne[j])&#123;            cout &lt;&lt; e[j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;\n\nVector实现#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5 + 10;vector&lt;int&gt; tb[N];signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    int m, n;    cin &gt;&gt; m &gt;&gt; n;    while(m -- )&#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;        tb[x].push_back(y);    &#125;    for(int i = 1; i &lt;= n; i ++ )&#123;        cout &lt;&lt; i &lt;&lt; &quot;: &quot;;        for(auto j : tb[i])&#123;            cout &lt;&lt; j &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;\n\n","categories":["课件","数据结构"],"tags":["C ++","算法基础"]},{"title":"堆没讲讲啥Huffman tree","url":"/2022/04/05/%E5%A0%86%E6%B2%A1%E8%AE%B2%E8%AE%B2%E5%95%A5Huffman-tree/","content":"今天数据结构课lzh听到讲到了Huffman tree，突然来了兴致，听起了课……\n\n\nHuffman tree\n讲的很好，但是…\n\nlzh 的疑惑课上讲的Huffman tree是二叉哈夫曼树，这里简述一下该树的特征，就是树的带权路径长度 (指的是从根结点到该结点之间的路径长度与该结点的权的乘积) 为树中所有叶子结点的带权路径长度之和。通常记作 WPL.\n二叉哈夫曼树的构造方法如下：\n\n将所有的节点放入某种集合中，该类集合有find_min()方法；\n在集合中找到2个最小的节点w1, w2；\n建立一个权值为w1，w2的树节点p，令树节点p为w1, w2的父节点；\n弹出w1, w2, 并将w1+w2插入新的集合中；\n重复2 ~ 4，直至集合的大小为1；\n\n嗯，看上去一切都如此的顺利成章，但是lzh不想止步于纸上，想自己写着玩玩，然而lzh发现了问题，这咋找集合里的最小值啊\nlzh 想写代码这里的数据结构是要要求动态维护最小值的，因为有频繁的push()&amp;pop()操作，yysy，讲Huffman tree不讲heap真的好吗，也有可能是lzh没听课呢，heap就是大家说的堆，堆是一种满二叉树，那么就跟大家讲讲堆的实现。\n#include &lt;queue&gt;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap;\n\n嗯，写好了\n不闹了，不闹了，正经点\n#include &lt;iostream&gt;#define lc (u &lt;&lt; 1)#define rc (u &lt;&lt; 1 | 1)#define pa (u &gt;&gt; 1)using namespace std;const int N = 1e6 + 10;int heap[N], cnt;void down(int u)&#123;    int t = u;    if ((lc) &lt;= cnt &amp;&amp; heap[lc] &lt; heap[t]) t = lc;    if ((rc) &lt;= cnt &amp;&amp; heap[rc] &lt; heap[t]) t = rc;        if (u != t)&#123;        swap(heap[t], heap[u]);        down(t);    &#125;&#125;void up(int u)&#123;    if (pa &amp;&amp; heap[pa] &gt; heap[u])&#123;        swap(heap[pa], heap[u]);        up(pa);    &#125;&#125;void push(int x)&#123;    heap[++ cnt] = x;    up(cnt);&#125;int top()&#123;    return heap[1];&#125;void pop()&#123;    swap(heap[1], heap[cnt]), cnt -- ;    down(1);&#125;\n\ntips: 本题用的是小根堆\n说说Huffman编码霍夫曼编码(Huffman Coding)是一种编码方法，霍夫曼编码是可变字长编码(VLC)的一种。\n霍夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。\n霍夫曼编码的具体步骤如下：\n\n将信源符号的概率按减小的顺序排队。\n\n把两个最小的概率相加，并继续这一步骤，始终将较高的概率分支放在右边，直到最后变成概率１。\n\n画出由概率１处到每个信源符号的路径，顺序记下沿路径的０和１，所得就是该符号的霍夫曼码字。   \n\n将每对组合的左边一个指定为0，右边一个指定为1（或相反）。\n\n\n霍夫曼编码的局限性\n利用霍夫曼编码，每个符号的编码长度只能为整数，所以如果源符号集的概率分布不是2负n次方的形式，则无法达到熵极限；输入符号数受限于可实现的码表尺寸；译码复杂；需要实现知道输入符号集的概率分布；没有错误保护功能。\n","categories":["算法","吐槽"],"tags":["C ++","课上"]},{"title":"组合数学笔记","url":"/2022/04/13/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"组合数应用甚为广泛，之前做过笔记，这次算补档。\n\n\n组合数学的先行版\n我记得我记过组合数学的笔记呀😡\n\n求组合数求组合数有很多种方式，我们需要通过数据范围来选出适合的方式，以如下例题为例👇\n\n给定 n 组询问，每组询问给定两个整数 a，b请你输出 C a b mod(10^9+7) 的值。\n\n第一种（递推式）公式： C(a, b) &#x3D; C (a - 1, b) + C(a - 1, b - 1)\n此类方法的数据范围： 10 ^ 3 &lt; b ≤ a &lt; 10 ^ 4\n代码实现：#include &lt;iostream&gt;using namespace std;const int N = 2010;const int MOD = 1e9 + 7;int c[N][N];void init()                         //时间复杂度O(n ^ 2), 空间复杂度O(n ^ 2)&#123;    for(int i = 0; i &lt; N; i ++ )    &#123;        for(int j = 0; j &lt;= i; j ++ )               &#123;            if(!j) c[i][j] = 1;                                                 else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;       //递推            &#125;    &#125;&#125;int main()&#123;    init();    int T;    cin &gt;&gt; T;    while(T -- )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; c[a][b] &lt;&lt; endl;    &#125;    return 0;&#125;\n\n第二种（乘法逆元和前缀乘预处理）公式： C(a, b) &#x3D; a! &#x2F; [(a - b)! × b!]   &#x3D;&#x3D;&gt;  C(a, b) &#x3D; a! × inv((a- b)! × b!) \n此类方法的数据范围： 1 ≤ b ≤a ≤ 10^5\n代码实现：#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;const int MOD = 1e9 + 7;int fact[N], inv[N];int qkm(int a, int k, int p)&#123;    int res = 1;    while(k)    &#123;        if(k &amp; 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;void init()&#123;    fact[0] = inv[0] = 1;           //c(0,0)的初始化    for(int i = 1; i &lt; N; i ++ )    &#123;        fact[i] = (LL)fact[i - 1] * i % MOD;        // 前缀乘or阶乘递推        inv[i] = (LL) inv[i - 1] * qkm(i, MOD - 2, MOD) % MOD;    &#125;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    init();    while(T -- )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; ((LL)fact[a] * inv[b] % MOD * inv[a- b] % MOD) % MOD &lt;&lt; endl;    &#125;    return 0;&#125;\n\n第三种（Lucas定理）公式： C(a, b) % P &#x3D; C(a%P, b%P) × C(a&#x2F;P, b&#x2F;P)\n此类方法的数据范围： 1≤b≤a≤10^18,  1≤p≤10^5\n代码实现：#include &lt;iostream&gt;using namespace std;typedef long long LL;int qkm(int a, int k, int p)&#123;    int res = 1;    while(k)    &#123;        if(k &amp; 1) res = res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;int C(int a, int b, int p)&#123;    if(b &gt; a) return 0;         //组合数不存在    int res = 1;    for(int i = 1, j = a; i &lt;= b; i ++ , j -- )    &#123;        res = (LL)res * j % p;              //阶乘的递推        res = (LL)res * qkm(i, p - 2, p) % p;       \t//乘法逆元    &#125;    return res;&#125;int lucas(LL a, LL b, int p)        //lucas定理中p为质数,且不宜太大&#123;    if(a &lt; p &amp;&amp;  b &lt; p) return C(a, b, p);    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T -- )    &#123;        LL a, b;        int p;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;        cout &lt;&lt; lucas(a, b, p) &lt;&lt; endl;    &#125;    return 0;&#125;\n\n第四种(对阶乘分解质因数 + 高精度)\n及其硬核，不是吗\n\n当以上范围超出以上三种或没有进行取余\n代码实现：#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 5010;int primes[N], cnt;int sum[N];bool st[N];void get_primes(int n)&#123;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        &#123;            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        &#125;    &#125;&#125;int get(int n, int p)&#123;    int res = 0;    while (n)    &#123;        res += n / p;        n /= p;    &#125;    return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)&#123;    vector&lt;int&gt; c;    int t = 0;    for (int i = 0; i &lt; a.size(); i ++ )    &#123;        t += a[i] * b;        c.push_back(t % 10);        t /= 10;    &#125;    while (t)    &#123;        c.push_back(t % 10);        t /= 10;    &#125;    return c;&#125;int main()&#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    get_primes(a);    for (int i = 0; i &lt; cnt; i ++ )    &#123;        int p = primes[i];        sum[i] = get(a, p) - get(a - b, p) - get(b, p);    &#125;    vector&lt;int&gt; res;    res.push_back(1);    for (int i = 0; i &lt; cnt; i ++ )        for (int j = 0; j &lt; sum[i]; j ++ )            res = mul(res, primes[i]);    for (int i = res.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, res[i]);    puts(&quot;&quot;);    return 0;&#125;\n\n下次拿python覆写一遍。\n番外の数——卡特兰数\n作为卡特兰数，这个世界上很多方案数都是卡特兰数，拥有和斐波那契数一样的地位\n\n表达形式：\n\nf(n)&#x3D;f(0)×f(n−1)+f(1)×f(n−2)+…+f(n−1)×f(0)\nf(n)&#x3D;C(2n, n) - C(2n , n - 1)\nf(n)&#x3D;C(2n, n) &#x2F; (n + 1)\n\n卡特兰数的初始化： f(0) &#x3D; 1\n例题展示给定 n 个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 0 的个数都不少于 1 的个数的序列有多少个。\n输出的答案对 10^9+7 取模。\n输入格式共一行，包含整数 n。\n输出格式共一行，包含一个整数，表示答案。\n数据范围1≤n≤10^5\n输入样例：3\n\n输出样例：5\n\n代码实现：#include &lt;iostream&gt;using namespace std;typedef long long LL;const int MOD = 1e9 + 7;int qkm(int a, int k, int p)&#123;    int res = 1;    while(k)    &#123;        if(k &amp; 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    int a = n * 2;    int b = n;    int f = 1;    for(int i = a; i &gt; b; i -- ) f = (LL)f * i % MOD;    for(int i = 1; i &lt;= n; i ++ ) f = (LL)f * qkm(i, MOD - 2, MOD) % MOD;    cout &lt;&lt; f &lt;&lt; endl;    return 0;&#125;\n\n暂完\n","categories":["算法","笔记"],"tags":["C ++"]}]