[{"title":"Arknight","url":"/2022/03/31/Arknight/","content":"这是我的个人博客\n\n\n\n豆⛟浆⛟\n\n","tags":["明日方舟"]},{"title":"组合数学笔记","url":"/2022/04/13/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"组合数应用甚为广泛，之前做过笔记，这次算补档。\n\n\n组合数学的先行版\n我记得我记过组合数学的笔记呀😡\n\n求组合数求组合数有很多种方式，我们需要通过数据范围来选出适合的方式，以如下例题为例👇\n\n给定 n 组询问，每组询问给定两个整数 a，b请你输出 C a b mod(10^9+7) 的值。\n\n第一种（递推式）公式： C(a, b) &#x3D; C (a - 1, b) + C(a - 1, b - 1)\n此类方法的数据范围： 10 ^ 3 &lt; b ≤ a &lt; 10 ^ 4\n代码实现：#include &lt;iostream&gt;using namespace std;const int N = 2010;const int MOD = 1e9 + 7;int c[N][N];void init()                         //时间复杂度O(n ^ 2), 空间复杂度O(n ^ 2)&#123;    for(int i = 0; i &lt; N; i ++ )    &#123;        for(int j = 0; j &lt;= i; j ++ )               &#123;            if(!j) c[i][j] = 1;                                                 else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;       //递推            &#125;    &#125;&#125;int main()&#123;    init();    int T;    cin &gt;&gt; T;    while(T -- )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; c[a][b] &lt;&lt; endl;    &#125;    return 0;&#125;\n\n第二种（乘法逆元和前缀乘预处理）公式： C(a, b) &#x3D; a! &#x2F; [(a - b)! × b!]   &#x3D;&#x3D;&gt;  C(a, b) &#x3D; a! × inv((a- b)! × b!) \n此类方法的数据范围： 1 ≤ b ≤a ≤ 10^5\n代码实现：#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;const int MOD = 1e9 + 7;int fact[N], inv[N];int qkm(int a, int k, int p)&#123;    int res = 1;    while(k)    &#123;        if(k &amp; 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;void init()&#123;    fact[0] = inv[0] = 1;           //c(0,0)的初始化    for(int i = 1; i &lt; N; i ++ )    &#123;        fact[i] = (LL)fact[i - 1] * i % MOD;        // 前缀乘or阶乘递推        inv[i] = (LL) inv[i - 1] * qkm(i, MOD - 2, MOD) % MOD;    &#125;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    init();    while(T -- )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; ((LL)fact[a] * inv[b] % MOD * inv[a- b] % MOD) % MOD &lt;&lt; endl;    &#125;    return 0;&#125;\n\n第三种（Lucas定理）公式： C(a, b) % P &#x3D; C(a%P, b%P) × C(a&#x2F;P, b&#x2F;P)\n此类方法的数据范围： 1≤b≤a≤10^18,  1≤p≤10^5\n代码实现：#include &lt;iostream&gt;using namespace std;typedef long long LL;int qkm(int a, int k, int p)&#123;    int res = 1;    while(k)    &#123;        if(k &amp; 1) res = res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;int C(int a, int b, int p)&#123;    if(b &gt; a) return 0;         //组合数不存在    int res = 1;    for(int i = 1, j = a; i &lt;= b; i ++ , j -- )    &#123;        res = (LL)res * j % p;              //阶乘的递推        res = (LL)res * qkm(i, p - 2, p) % p;       \t//乘法逆元    &#125;    return res;&#125;int lucas(LL a, LL b, int p)        //lucas定理中p为质数,且不宜太大&#123;    if(a &lt; p &amp;&amp;  b &lt; p) return C(a, b, p);    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T -- )    &#123;        LL a, b;        int p;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;        cout &lt;&lt; lucas(a, b, p) &lt;&lt; endl;    &#125;    return 0;&#125;\n\n第四种(对阶乘分解质因数 + 高精度)\n及其硬核，不是吗\n\n当以上范围超出以上三种或没有进行取余\n代码实现：#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 5010;int primes[N], cnt;int sum[N];bool st[N];void get_primes(int n)&#123;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        &#123;            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        &#125;    &#125;&#125;int get(int n, int p)&#123;    int res = 0;    while (n)    &#123;        res += n / p;        n /= p;    &#125;    return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)&#123;    vector&lt;int&gt; c;    int t = 0;    for (int i = 0; i &lt; a.size(); i ++ )    &#123;        t += a[i] * b;        c.push_back(t % 10);        t /= 10;    &#125;    while (t)    &#123;        c.push_back(t % 10);        t /= 10;    &#125;    return c;&#125;int main()&#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    get_primes(a);    for (int i = 0; i &lt; cnt; i ++ )    &#123;        int p = primes[i];        sum[i] = get(a, p) - get(a - b, p) - get(b, p);    &#125;    vector&lt;int&gt; res;    res.push_back(1);    for (int i = 0; i &lt; cnt; i ++ )        for (int j = 0; j &lt; sum[i]; j ++ )            res = mul(res, primes[i]);    for (int i = res.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, res[i]);    puts(&quot;&quot;);    return 0;&#125;\n\n下次拿python覆写一遍。\n番外の数——卡特兰数\n作为卡特兰数，这个世界上很多方案数都是卡特兰数，拥有和斐波那契数一样的地位\n\n表达形式：\n\nf(n)&#x3D;f(0)×f(n−1)+f(1)×f(n−2)+…+f(n−1)×f(0)\nf(n)&#x3D;C(2n, n) - C(2n , n - 1)\nf(n)&#x3D;C(2n, n) &#x2F; (n + 1)\n\n卡特兰数的初始化： f(0) &#x3D; 1\n例题展示给定 n 个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 0 的个数都不少于 1 的个数的序列有多少个。\n输出的答案对 10^9+7 取模。\n输入格式共一行，包含整数 n。\n输出格式共一行，包含一个整数，表示答案。\n数据范围1≤n≤10^5\n输入样例：3\n\n输出样例：5\n\n代码实现：#include &lt;iostream&gt;using namespace std;typedef long long LL;const int MOD = 1e9 + 7;int qkm(int a, int k, int p)&#123;    int res = 1;    while(k)    &#123;        if(k &amp; 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    int a = n * 2;    int b = n;    int f = 1;    for(int i = a; i &gt; b; i -- ) f = (LL)f * i % MOD;    for(int i = 1; i &lt;= n; i ++ ) f = (LL)f * qkm(i, MOD - 2, MOD) % MOD;    cout &lt;&lt; f &lt;&lt; endl;    return 0;&#125;\n\n暂完\n","categories":["算法","笔记"],"tags":["C ++"]},{"title":"链表与邻接表","url":"/2023/01/01/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/","content":"本章无需前置知识\n\n\n链表与邻接表\n此处我介绍链式前向星的写法\n\n链式前向星的写法是使用数组去模拟链表，因不用反复申请空间而效率很高。而其核心思想就是先申请个内存池，动态开点。\n链表单向链表模板#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;//此处内存池大小为N，-1是链表结束标记，起初链表为空，head=-1int head = -1, ne[N], node[N], idx = -1;\tvoid add(int x)&#123;    node[++ idx] = x, ne[idx] = head, head = idx;&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    int n;    cin &gt;&gt; n;    int m = n;    while(m -- )&#123;        int x;        cin &gt;&gt; x;        add(x);    &#125;    for(int i = head; ~i; i = ne[i])&#123;        cout &lt;&lt; node[i] &lt;&lt; endl;    &#125;&#125;\n\n双向链表模板#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int m;int l[N], r[N], e[N], idx = 2;void init()&#123;    r[0] = 1, l[1] = 0;&#125;void insert_l(int x)&#123;    e[idx] = x;    l[idx] = 0;    r[idx] = r[0];    l[r[0]] = idx, r[0] = idx ++ ;&#125;void insert_r(int x)&#123;    e[idx] = x;    l[idx] = l[1];    r[idx] = 1;    r[l[1]] = idx, l[1] = idx ++ ;&#125;void remove(int i)&#123;    l[r[i]] = l[i], r[l[i]] = r[i];&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    cin &gt;&gt; m;    init();    while(m -- )&#123;        char opt;        int x;        cin &gt;&gt; opt &gt;&gt; x;        if(opt == &#x27;l&#x27;)&#123;            insert_l(x);        &#125;else if(opt == &#x27;r&#x27;)&#123;            insert_r(x);        &#125;else&#123;            remove(x);        &#125;    &#125;    for(int i = r[0]; i != 1; i = r[i])&#123;        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for(int i = l[1]; i != 0; i = l[i])&#123;        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    &#125;    &#125;\n\n邻接表\n可以存储树状数据的一种数据结构\n\n邻接表，做个简单的假设：有一数组记录了若干节点，数组节点上存储一链表，该链表记录了该节点所直接能通往的所有节点。这就是所谓的邻接，而这类似二维数组的数据结构，我们可以称之为邻接表。\n邻接表模板(数组实现)#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;const int M = 1e6 + 10;int head[N], ne[M], e[M], idx;void add(int x, int y)&#123;    // x -&gt; y    e[++ idx] = y, ne[idx] = head[x], head[x] = idx;&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    int m, n;    cin &gt;&gt; m &gt;&gt; n;    while(m -- )&#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;        add(x, y);        //add(y, x) 双向边    &#125;    //遍历各个点的邻接点    for(int i = 1; i &lt;= n; i ++ )&#123;        cout &lt;&lt; i &lt;&lt; &quot;: &quot;;        for(int j = head[i]; j; j = ne[j])&#123;            cout &lt;&lt; e[j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;\n\n使用Vector实现#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5 + 10;vector&lt;int&gt; tb[N];signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    int m, n;    cin &gt;&gt; m &gt;&gt; n;    while(m -- )&#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;        tb[x].push_back(y);    &#125;    for(int i = 1; i &lt;= n; i ++ )&#123;        cout &lt;&lt; i &lt;&lt; &quot;: &quot;;        for(auto j : tb[i])&#123;            cout &lt;&lt; j &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;\n\n邻接表存储树、图结构何为树：\n\n\n何为图：\n\n不严谨的来说，有环树为图，无环图为树。图可以描述多对多的关系，树可描述一对多的关系 （父子关系）\n树的节点与边的数量关系为 ：边数 &#x3D; 节点数 - 1\n图的节点与边的数量关系：设节点数为N，边数为M —— M ≤ (N-1)×N&#x2F;2\n邻接表存储：\n\n以至于对其的遍历方法，等以后再说吧🎃\n例题题目描述给定一个长度为 n 的序列 A，A 中的数各不相同。对于 A 中的每一个数Ai，求：min(1≤j&lt;i)⁡∣Ai−Aj∣以及令上式取到最小值的 j（记为 Pi）。若最小值点不唯一，则选择使 Aj较小的那个。\n输入描述:第一行一个整数n，第二行n个数A1~An。\n\n输出描述:n-1行，每行2个用空格隔开的整数。分别表示当i取2~n时，对应的 min(1≤j&lt;i)⁡∣Ai−Aj∣和Pi的值。\n\n参考代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;using PII = pair&lt;int,int&gt;;const int N = 1e5 + 10;struct Node&#123;    int v, id;    int nxt, pre;    bool operator&lt;(const Node&amp; k)const&#123;        if(v == k.v)            return id &lt; k.id;        else            return v &lt; k.v;    &#125;&#125;q[N];int st[N];int n;PII ans[N];signed main()&#123;//     freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    ios::sync_with_stdio(false);    cin &gt;&gt; n;    q[0].v = 1e9, q[n+1].v = -1e9;    for(int i = 1; i &lt;= n; i ++ )&#123;        cin &gt;&gt; q[i].v;        q[i].id = i;    &#125;    sort(q+1, q+1+n);    for(int i = 1; i &lt;= n; i ++ )&#123;        q[i].nxt = i+1;        q[i].pre = i-1;        st[q[i].id] = i;    &#125;    for(int i = n; i &gt; 1; i -- )&#123;        int j = st[i], j1 = q[j].nxt, j2 = q[j].pre;        int r1 = abs(q[j1].v - q[j].v), r2 = abs(q[j2].v - q[j].v);        if(r1 &gt;= r2) ans[i] = &#123;r2, q[j2].id&#125;;        else ans[i] = &#123;r1, q[j1].id&#125;;        q[j1].pre = j2;        q[j2].nxt = j1;    &#125;    for(int i = 2; i &lt;= n; i ++ )&#123;        cout &lt;&lt; ans[i].first &lt;&lt; &quot; &quot; &lt;&lt; ans[i].second &lt;&lt; endl;    &#125;&#125;\n\n\n\n课后习题\n因为过于基础，所以不太好找例题，所以本章就留点课后练习吧\n\n单链表:\n实现一个单链表，链表初始为空，支持三种操作：\n\n向链表头插入一个数；\n删除第 k 个插入的数后面的数；\n在第 k 个插入的数后插入一个数。\n\n现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。\n注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。\n输入格式第一行包含整数 M，表示操作次数。\n接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：\n\nH x，表示向链表头插入一个 x。\nD k，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。\nI k x，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。\n\n输出格式共一行，将整个链表从头到尾输出。\n数据范围1≤M≤100000所有操作保证合法。\n输入样例：10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6\n\n输出样例：6 4 6 5\n\n双链表:\n实现一个双链表，双链表初始为空，支持 5 种操作：\n\n在最左侧插入一个数；\n在最右侧插入一个数；\n将第 k 个插入的数删除；\n在第 k 个插入的数左侧插入一个数；\n在第 k 个插入的数右侧插入一个数\n\n现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。\n注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。\n输入格式第一行包含整数 M，表示操作次数。\n接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：\n\nL x，表示在链表的最左端插入数 x。\nR x，表示在链表的最右端插入数 x。\nD k，表示将第 k 个插入的数删除。\nIL k x，表示在第 k 个插入的数左侧插入一个数。\nIR k x，表示在第 k 个插入的数右侧插入一个数。\n\n输出格式共一行，将整个链表从左到右输出。\n数据范围1≤M≤100000所有操作保证合法。\n输入样例：10R 7D 1L 3IL 2 10D 3IL 2 7L 8R 9IL 4 7IR 2 2\n\n输出样例：8 7 7 3 2 9\n\n","categories":["课件","数据结构"],"tags":["C ++","算法基础"]},{"title":"简单的递归学习","url":"/2023/01/02/%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92%E5%AD%A6%E4%B9%A0/","content":"本章无需前置知识，但最好了解如何存储树结构（可参考链表与邻接表）🙂\n\n\n递归（入门）我们先来看基础的递归写法结构：\nvoid dfs()&#123;    if(condition()) return;\t//结束条件    dfs();&#125;\n\n再来看看经典的求最大公因数gcd递归写法：\nint gcd(int a, int b)&#123;   return b ? gcd(b, a%b) : a; &#125;\n\n可见递归从形式上来看就是自己调用自己，而自己调用自己也存在着无法停下的风险，所以需要条件来结束递归。\n而就形式上的了解是不可能掌握递归的。所以，接下来我们来讲递归的常用应用场景：树状结构的问题。\n递归遍历树 \n先来个问题，面对一棵树，怎么遍历？\n按照线性（比如数组）的遍历方法肯定是不行的（邻接表这么遍历也太掉逼格了）这里我们就可以使用递归，之后在图论中我们称此为dfs（深度优先搜索）。我们先来一个demo\ndemo自己编的，不要在意\n\n这里有棵树，每个节点上都有数值，定义每个节点的价值为节点数值乘上其深度（距离根节点的距离+1，根节点深度为1），树的价值是所有节点价值的和，求出给定树的价值。\n\ninput\n6\t\t\t//树有的节点数1 2 3 4 5 6 //第i个数是节点i的数值1 2 \t\t//节点1 指向 节点22 3 1 4 2 5 5 6 \n\noutput\n61\n\ncode\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int n;int h[N], ne[N], e[N], idx;int v[N];void init()&#123;    memset(h, -1, sizeof h);    idx =-1;&#125;void add(int x, int y)&#123;    e[++ idx] = y, ne[idx] = h[x], h[x] = idx;&#125;int ans;void dfs(int u, int deep)&#123;    ans += v[u]*deep;    for(int i = h[u]; ~i; i = ne[i])&#123;        dfs(e[i], deep + 1);    &#125;&#125;signed main()&#123;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    init();    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i ++ )&#123;        cin &gt;&gt; v[i];    &#125;    for(int i = 1; i &lt; n; i ++ )&#123;        int x, y;        cin &gt;&gt; x &gt;&gt; y;        add(x, y);    &#125;    dfs(1, 1);    cout &lt;&lt; ans &lt;&lt;endl;&#125;\n\n重点看一下这段代码：\nvoid dfs(int u, int deep)&#123;    //u为当前遍历的节点，deep为当前深度    ans += v[u]*deep;    for(int i = h[u]; ~i; i = ne[i])&#123;        dfs(e[i], deep + 1);\t//遍历u所邻接的节点e[i]，树的深度加一    &#125;&#125;\n","categories":["课件","搜索"],"tags":["C ++","算法基础"]}]