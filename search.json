[{"title":"Arknight","url":"/2022/03/31/Arknight/","content":"这是我的个人博客\n\n\n\n豆⛟浆⛟\n\n","tags":["明日方舟"]},{"title":"堆没讲讲啥Huffman tree","url":"/2022/04/05/%E5%A0%86%E6%B2%A1%E8%AE%B2%E8%AE%B2%E5%95%A5Huffman-tree/","content":"今天数据结构课lzh听到讲到了Huffman tree，突然来了兴致，听起了课……\n\n\nHuffman tree\n讲的很好，但是…\n\nlzh 的疑惑课上讲的Huffman tree是二叉哈夫曼树，这里简述一下该树的特征，就是树的带权路径长度 (指的是从根结点到该结点之间的路径长度与该结点的权的乘积) 为树中所有叶子结点的带权路径长度之和。通常记作 WPL.\n二叉哈夫曼树的构造方法如下：\n\n将所有的节点放入某种集合中，该类集合有find_min()方法；\n在集合中找到2个最小的节点w1, w2；\n建立一个权值为w1，w2的树节点p，令树节点p为w1, w2的父节点；\n弹出w1, w2, 并将w1+w2插入新的集合中；\n重复2 ~ 4，直至集合的大小为1；\n\n嗯，看上去一切都如此的顺利成章，但是lzh不想止步于纸上，想自己写着玩玩，然而lzh发现了问题，这咋找集合里的最小值啊\nlzh 想写代码这里的数据结构是要要求动态维护最小值的，因为有频繁的push()&amp;pop()操作，yysy，讲Huffman tree不讲heap真的好吗，也有可能是lzh没听课呢，heap就是大家说的堆，堆是一种满二叉树，那么就跟大家讲讲堆的实现。\n#include &lt;queue&gt;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap;\n\n嗯，写好了\n不闹了，不闹了，正经点\n#include &lt;iostream&gt;#define lc (u &lt;&lt; 1)#define rc (u &lt;&lt; 1 | 1)#define pa (u &gt;&gt; 1)using namespace std;const int N = 1e6 + 10;int heap[N], cnt;void down(int u)&#123;    int t = u;    if ((lc) &lt;= cnt &amp;&amp; heap[lc] &lt; heap[t]) t = lc;    if ((rc) &lt;= cnt &amp;&amp; heap[rc] &lt; heap[t]) t = rc;        if (u != t)&#123;        swap(heap[t], heap[u]);        down(t);    &#125;&#125;void up(int u)&#123;    if (pa &amp;&amp; heap[pa] &gt; heap[u])&#123;        swap(heap[pa], heap[u]);        up(pa);    &#125;&#125;void push(int x)&#123;    heap[++ cnt] = x;    up(cnt);&#125;int top()&#123;    return heap[1];&#125;void pop()&#123;    swap(heap[1], heap[cnt]), cnt -- ;    down(1);&#125;\n\ntips: 本题用的是小根堆\n说说Huffman编码霍夫曼编码(Huffman Coding)是一种编码方法，霍夫曼编码是可变字长编码(VLC)的一种。\n霍夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。\n霍夫曼编码的具体步骤如下：\n\n将信源符号的概率按减小的顺序排队。\n\n把两个最小的概率相加，并继续这一步骤，始终将较高的概率分支放在右边，直到最后变成概率１。\n\n画出由概率１处到每个信源符号的路径，顺序记下沿路径的０和１，所得就是该符号的霍夫曼码字。   \n\n将每对组合的左边一个指定为0，右边一个指定为1（或相反）。\n\n\n霍夫曼编码的局限性\n利用霍夫曼编码，每个符号的编码长度只能为整数，所以如果源符号集的概率分布不是2负n次方的形式，则无法达到熵极限；输入符号数受限于可实现的码表尺寸；译码复杂；需要实现知道输入符号集的概率分布；没有错误保护功能。\n","categories":["算法"],"tags":["C ++","吐槽"]}]